<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/dungeon/Dungeon.js | micrungeon</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Phaser 3 hybrid game"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="micrungeon"><meta property="twitter:description" content="Phaser 3 hybrid game"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/blackjack26/micrungeon"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Difficulty">Difficulty</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Direction">Direction</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Edge">Edge</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Orientation">Orientation</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RoomType">RoomType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Door">Door</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-DungeonConfig">DungeonConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-HealthBarConfig">HealthBarConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ItemUseConfig">ItemUseConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RandomNumberRange">RandomNumberRange</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RoomAttachment">RoomAttachment</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-RoomConfig">RoomConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-SpriteConfig">SpriteConfig</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-TilePosition">TilePosition</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#battle">battle</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/battle/Battle.js~Battle.html">Battle</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/battle/BattleDrop.js~BattleDrop.html">BattleDrop</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/battle/HealthBar.js~HealthBar.html">HealthBar</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#dungeon">dungeon</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/dungeon/Dungeon.js~Dungeon.html">Dungeon</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/dungeon/Hallway.js~Hallway.html">Hallway</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/dungeon/Room.js~Room.html">Room</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/dungeon/TilemapVisibility.js~TilemapVisibility.html">TilemapVisibility</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-debugMap">debugMap</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Tileset">Tileset</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-Tiles">Tiles</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#entity">entity</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/entity/Enemy.js~Enemy.html">Enemy</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/entity/Entity.js~Entity.html">Entity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/entity/Player.js~Player.html">Player</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#entity-items">entity/items</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/entity/items/BugSpray.js~BugSpray.html">BugSpray</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/entity/items/Injection.js~Injection.html">Injection</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/entity/items/Inventory.js~Inventory.html">Inventory</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/entity/items/Item.js~Item.html">Item</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/entity/items/ItemDrop.js~ItemDrop.html">ItemDrop</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/entity/items/Timelapse.js~Timelapse.html">Timelapse</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/entity/items/VorpalSword.js~VorpalSword.html">VorpalSword</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-itemClass">itemClass</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ItemType">ItemType</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#minigames">minigames</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/minigames/DanceDance.js~DanceDance.html">DanceDance</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/minigames/MiniGame.js~MiniGame.html">MiniGame</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scenes">scenes</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/scenes/BootScene.js~BootScene.html">BootScene</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/scenes/GameScene.js~GameScene.html">GameScene</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/scenes/InventoryScene.js~InventoryScene.html">InventoryScene</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/scenes/PauseScene.js~PauseScene.html">PauseScene</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/scenes/TitleScene.js~TitleScene.html">TitleScene</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#scenes-elements">scenes/elements</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/scenes/elements/Message.js~Message.html">Message</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#util">util</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util/KeyBinding.js~KeyBinding.html">KeyBinding</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util/LightPipeline.js~LightPipeline.html">LightPipeline</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/util/Random.js~Random.html">Random</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-addDynamicAnim">addDynamicAnim</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-addStaticAnim">addStaticAnim</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createAnimations">createAnimations</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/dungeon/Dungeon.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import Random from &apos;../util/Random&apos;;
import { Room, RoomType } from &apos;./Room&apos;;
import Tiles from &apos;./Tiles&apos;;
import Hallway from &apos;./Hallway&apos;;
import { Direction } from &apos;../globals&apos;;

/**
 * The default config for the dungeon
 * @type {DungeonConfig}
 */
const baseConfig = {
  width: 55,
  height: 55,
  randomSeed: undefined,
  doorPadding: 1,
  rooms: {
    width: {
      min: 7,
      max: 21,
      even: false
    },
    height: {
      min: 7,
      max: 17,
      even: false
    },
    maxArea: 250,
    maxRooms: 50
  }
};

/**
 * The minimum length of a hallway between two rooms
 * @type {number}
 */
const MIN_HALL_LENGTH = 2;

/**
 * The maximum length of a hallway between two rooms
 * @type {number}
 */
const MAX_HALL_LENGTH = 8;

/**
 * The minimum width of a room regardless of the dungeon&apos;s config
 * @type {number}
 */
const MIN_WIDTH = 3;

/**
 * The minimum height of a room regardless of the dungeon&apos;s config
 * @type {number}
 */
const MIN_HEIGHT = 3;

/**
 * The number of times to attempt placing a room in the dungeon
 * @type {number}
 */
const MAX_RETRY_COUNT = 150;

/**
 * The dungeon class to generate dungeon rooms and positions
 */
export default class Dungeon {
  /**
   * @constructor
   * @param {DungeonConfig} config
   */
  constructor( config = {} ) {
    const rooms = config.rooms || {};
    rooms.width = Object.assign( {}, baseConfig.rooms.width, rooms.width );
    rooms.height = Object.assign( {}, baseConfig.rooms.height, rooms.height );
    rooms.maxArea = rooms.maxArea || baseConfig.rooms.maxArea;
    rooms.maxRooms = rooms.maxRooms || baseConfig.rooms.maxRooms;

    // Clamp room size
    rooms.width.min = Math.max( MIN_WIDTH, rooms.width.min );
    rooms.height.min = Math.max( MIN_HEIGHT, rooms.height.min );
    rooms.width.max = Math.max( rooms.width.max, rooms.width.min );
    rooms.height.max = Math.max( rooms.height.max, rooms.height.min );

    // Avoid an impossibly small maxArea
    const minArea = rooms.width.min * rooms.height.min;
    rooms.maxArea = Math.max( rooms.maxArea, minArea );

    /**
     * The number of tiles required on each side of a door
     * @type {number}
     */
    this.doorPadding = config.doorPadding || baseConfig.doorPadding;
    
    /**
     * The width of the dungeon in tiles
     * @type {number}
     */
    this.width = config.width || baseConfig.width;
    
    /**
     * The height of the dungeon in tiles
     * @type {number}
     */
    this.height = config.height || baseConfig.height;
    
    /**
     * The configuration for room generation
     * @type {RoomConfig}
     */
    this.roomConfig = rooms;

    /**
     * The list of rooms in the dungeon
     * @type {Array.&lt;Room&gt;}
     */
    this.rooms = [];
    
    /**
     * The random number generator
     * @private
     * @type {Random}
     */
    this.r = new Random( config.randomSeed );

    /**
     * 2D grid matching map dimensions where every element contains an array of
     * all the rooms in that location
     * @type {Array.&lt;Array.&lt;Array.&lt;Room&gt;&gt;&gt;}
     */
    this.roomGrid = [];

    /**
     * A map of the connections between rooms and hallways
     * @type {Object}
     */
    this.connections = {};
    
    /**
     * The starting room for the dungeon
     * @type {Room}
     */
    this.startRoom = null;

    this.generate();
    
    /**
     * The full map of the dungeon
     * @type {Array.&lt;Array.&lt;Tiles&gt;&gt;}
     */
    this.tiles = this.getTiles();
    
    this.rooms.forEach( ( room ) =&gt; room.updateDoorPositions() );
  }

  /**
   * Generates the dungeon and populates it with rooms and hallways
   */
  generate() {
    // Populate empty 2D array
    for ( let r = 0; r &lt; this.height; r++ ) {
      this.roomGrid.push( [] );
      for ( let c = 0; c &lt; this.width; c++ ) {
        this.roomGrid[ r ].push( [] );
      }
    }

    // Seed the map with a starting randomly sized room in the center of the map
    const room = this.createRandomRoom();
    room.setPosition(
      Math.floor( this.width / 2 ) - Math.floor( room.width / 2 ),
      Math.floor( this.height / 2 ) - Math.floor( room.height / 2 )
    );
    this.addRoom( room );
    this.connections[ room.id ] = [];

    // Continue generating rooms until we hit the cap or have hit the maximum
    // iterations (usually due to not being able to fit more rooms)
    let i = this.roomConfig.maxRooms * 5;
    while ( this.rooms.length &lt; this.roomConfig.maxRooms &amp;&amp; i &gt; 0 ) {
      this.generateRoom();
      i -= 1;
    }

    // Try to make 2 more random hallways
    this.generateRandomHallways();

    // Select item rooms
    this.selectItemRooms();

    // Pick the starting room
    this.selectStartRoom();

    // Pick the ending room
    this.selectEndRoom();
  }

  /**
   * Creates a room of random width and height
   * @private
   * @return {Room} the created room
   */
  createRandomRoom() {
    let width = 0;
    let height = 0;
    let area = 0;

    // Find width and height using min/max sizes while keeping under maxArea
    const config = this.roomConfig;
    do {
      width = this.r.randInt( config.width.min, config.width.max,
        config.width.even );
      height = this.r.randInt( config.height.min, config.height.max,
        config.height.even );
      area = width * height;
    } while ( area &gt; config.maxArea );

    return new Room( width, height );
  }

  /**
   * Creates a new room and tries to add it to the dungeon
   * @private
   */
  generateRoom() {
    const room = this.createRandomRoom();

    let i = MAX_RETRY_COUNT;
    while ( i &gt; 0 ) {
      // Attempt to find another room to attach this one to
      const result = this.findRoomAttachment( room );
      room.setPosition( result.x, result.y );

      // Try to add it. If successful, add the door and hallway between
      if ( this.addRoom( room ) ) {
        const [ door1, door2 ] =
          this.findNewDoorLocation( room, result );

        // Try to add hallway, if unsuccessful, remove room
        if ( this.addHallway( door1, door2, result.dist ) ) {
          this.connections[ room.id ] = [ result.target.id ];
          this.connections[ result.target.id ].push( room.id );

          this.addDoor( door1 );
          this.addDoor( door2 );
          break;
        }
        else {
          this.removeRoom( room );
        }
      }

      i -= 1;
    }
  }

  /**
   * Generates two random hallways between two random rooms to try and make a
   * loop in the dungeon.
   * @private
   */
  generateRandomHallways() {
    let count = 0;
    let retries = MAX_RETRY_COUNT;

    do {
      retries--;

      /** @type Room */
      const room1 = this.r.randPick(
        this.rooms.filter( ( room ) =&gt; !( room instanceof Hallway ) )
      );

      /** @type Room */
      const room2 = this.r.randPick(
        this.rooms.filter(
          ( room ) =&gt; !( room instanceof Hallway ) &amp;&amp; room.id !== room1.id )
      );

      // Prevent multiple connections between the same room
      if ( this.connections[ room1.id ].indexOf( room2.id ) &gt;= 0 ) {
        continue;
      }

      // Get the direction of the hallway
      let direction;
      if ( room1.overlapsX( room2 ) ) {
        if ( room1.top &lt; room2.top ) {
          direction = Direction.NORTH;
        }
        else {
          direction = Direction.SOUTH;
        }
      }
      else if ( room1.overlapsY( room2 ) ) {
        if ( room1.left &lt; room2.left ) {
          direction = Direction.WEST;
        }
        else {
          direction = Direction.EAST;
        }
      }
      else {
        // No hallway possible
        continue;
      }

      const [ door1, door2 ] = this.findNewDoorLocation( room1,
        {
          target: room2,
          direction: direction
        } );
      const dist = Math.sqrt( Math.pow( door1.x - door2.x, 2 ) +
        Math.pow( door1.y - door2.y, 2 ) );

      // Make sure the doors are not on the corners of the room
      if ( room1.isCorner( door1 ) || room2.isCorner( door2 ) ) {
        continue;
      }

      // Try to add the hallway
      if ( this.addHallway( door1, door2, dist - 1 ) ) {
        this.connections[ room1.id ].push( room2.id );
        this.connections[ room2.id ].push( room1.id );

        this.addDoor( door1 );
        this.addDoor( door2 );
        count++;
      }
    } while ( retries &gt; 0 &amp;&amp; count &lt; 3 );
  }

  /**
   * Selects the rooms in the dungeon that are small and places items in them
   * @private
   */
  selectItemRooms() {
    this.rooms
      .filter( ( room ) =&gt; room.type !== RoomType.HALLWAY )
      .sort( ( a, b ) =&gt; a.area &lt; b.area ? -1 : ( a.area === b.area ? 0 : 1 ) )
      .slice( 0, 5 )
      .forEach( ( room ) =&gt; {
        room.type = RoomType.ITEM;
      } );
  }

  /**
   * Selects the starting room
   * @private
   */
  selectStartRoom() {
    /**
     * The starting room
     * @type Room
     */
    let sRoom;
    do {
      sRoom = this.r.randPick(
        this.rooms.filter( ( room ) =&gt; !( room instanceof Hallway ) )
      );
    } while ( this.connections[ sRoom.id ].length &lt; 3 );
    sRoom.type = RoomType.START;
    sRoom.tiles[ sRoom.centerY - sRoom.y ][ sRoom.centerX - sRoom.x ]
      = Tiles.START; // TODO: remove, for visualizations
    this.startRoom = sRoom;
  }

  /**
   * Selects the ending room
   * @private
   */
  selectEndRoom() {
    /**
     * The end room
     * @type Room
     */
    let eRoom;
    do {
      eRoom = this.r.randPick(
        this.rooms.filter( ( room ) =&gt; !( room instanceof Hallway ) )
      );
    } while ( this.connections[ eRoom.id ].length &gt;= 2 );
    eRoom.type = RoomType.START;
    eRoom.tiles[ eRoom.centerY - eRoom.y ][ eRoom.centerX - eRoom.x ]
      = Tiles.END; // TODO: remove, for visualizations
  }

  /**
   * Adds a room to the current dungeon
   * @private
   * @param {Room} room The room to add
   * @return {boolean} True if the room was successfully added
   */
  addRoom( room ) {
    // if the room won&apos;t fit, we don&apos;t add it
    if ( !this.canFitRoom( room ) ) {
      return false;
    }

    room.id = this.rooms.length;
    this.rooms.push( room );

    // Update all tiles in the roomGrid to indicate that this room is sitting
    // on them.
    for ( let r = room.top; r &lt;= room.bottom; r++ ) {
      for ( let c = room.left; c &lt;= room.right; c++ ) {
        this.roomGrid[ r ][ c ].push( room );
      }
    }
    return true;
  }

  /**
   * Removes a room from the current dungeon
   * @private
   * @param {Room} room The room to remove
   */
  removeRoom( room ) {
    this.rooms = this.rooms.filter( ( r ) =&gt; r !== room );
    for ( let r = room.top; r &lt;= room.bottom; r++ ) {
      for ( let c = room.left; c &lt;= room.right; c++ ) {
        this.roomGrid[ r ][ c ] =
          this.roomGrid[ r ][ c ].filter( ( r ) =&gt; r !== room );
      }
    }
  }

  /**
   * Adds a door between rooms in a dungeon
   * @private
   * @param {TilePosition} position The position of the door
   */
  addDoor( position ) {
    // Get all the rooms at the location of the door
    const rooms = this.roomGrid[ position.y ][ position.x ];
    for ( const room of rooms ) {
      // convert the door position from world space to room space
      const x = position.x - room.x;
      const y = position.y - room.y;

      // set the tile to be a door
      room.tiles[ y ][ x ] = Tiles.DOOR;
    }
  }

  /**
   * Adds a hallway between two doors in the dungeon
   * @private
   * @param {TilePosition} door1 The first door
   * @param {TilePosition} door2 The second door
   * @param {number} dist The distance between the two doors
   * @return {boolean} True if the hallway could be added (or no hallway)
   */
  addHallway( door1, door2, dist ) {
    if ( dist &lt; MIN_HALL_LENGTH ) {
      return false;
    }

    // No hallway if doors are next to each other
    if ( dist === 0 ) {
      return true;
    }
    return this.addRoom( Hallway.fromDoors( door1, door2 ) );
  }

  /**
   * Finds a room that the given room can be placed next to
   * @private
   * @param {Room} room The room to place
   * @return {RoomAttachment} The position for the new room and target room
   */
  findRoomAttachment( room ) {
    // Pick a random room (filter out the hallways)
    const r = this.r.randPick(
      this.rooms.filter( ( room ) =&gt; !( room instanceof Hallway ) )
    );

    let x = 0;
    let y = 0;
    const pad = 2 * this.doorPadding;

    // The distance between the rooms
    const dist = this.r.randInt( MIN_HALL_LENGTH, MAX_HALL_LENGTH );
    const direction = this.r.randDirection();

    // Randomly position this room on one of the sides of the random room
    switch ( direction ) {
      case Direction.NORTH:
        x = this.r.randInt( r.left - ( room.width - 1 ) + pad, r.right - pad );
        y = r.top - room.height - dist;
        break;
      case Direction.WEST:
        x = r.left - room.width - dist;
        y = this.r.randInt( r.top - ( room.height - 1 ) + pad, r.bottom - pad );
        break;
      case Direction.EAST:
        x = r.right + 1 + dist;
        y = this.r.randInt( r.top - ( room.height - 1 ) + pad, r.bottom - pad );
        break;
      case Direction.SOUTH:
        x = this.r.randInt( r.left - ( room.width - 1 ) + pad, r.right - pad );
        y = r.bottom + 1 + dist;
        break;
    }

    return {
      x: x,
      y: y,
      target: r,
      dist: dist,
      direction: direction
    };
  }

  /**
   * Gets the location for the two new doors
   * @private
   * @param {Room} room1 The first room
   * @param {{target: Room, direction: Direction}} obj The second room and
   *          direction
   * @return {Array.&lt;TilePosition&gt;} an array of door positions
   */
  findNewDoorLocation( room1, { target: room2, direction } ) {
    const door1 = {
      x: -1,
      y: -1
    };
    const door2 = {
      x: -1,
      y: -1
    };

    if ( Direction.NORTH === direction ) {
      door1.x = door2.x = this.r.randInt(
        Math.floor( Math.max( room2.left, room1.left ) + this.doorPadding ),
        Math.floor( Math.min( room2.right, room1.right ) - this.doorPadding )
      );
      door1.y = room1.y + room1.height - 1;
      door2.y = room2.y;
    }
    else if ( Direction.WEST === direction ) {
      door1.x = room1.x + room1.width - 1;
      door2.x = room2.x;
      door1.y = door2.y = this.r.randInt(
        Math.floor( Math.max( room2.top, room1.top ) + this.doorPadding ),
        Math.floor( Math.min( room2.bottom, room1.bottom ) - this.doorPadding )
      );
    }
    else if ( Direction.EAST === direction ) {
      // East
      door1.x = room1.x;
      door2.x = room2.x + room2.width - 1;
      door1.y = door2.y = this.r.randInt(
        Math.floor( Math.max( room2.top, room1.top ) + this.doorPadding ),
        Math.floor( Math.min( room2.bottom, room1.bottom ) - this.doorPadding )
      );
    }
    else if ( Direction.SOUTH === direction ) {
      // South
      door1.x = door2.x = this.r.randInt(
        Math.floor( Math.max( room2.left, room1.left ) + this.doorPadding ),
        Math.floor( Math.min( room2.right, room1.right ) - this.doorPadding )
      );
      door1.y = room1.y;
      door2.y = room2.y + room2.height - 1;
    }

    return [ door1, door2 ];
  }

  /**
   * Checks to see if the given room can fit inside the dungeon
   * @private
   * @param {Room} room The room to check
   * @return {boolean} True if the room can fit in the dungeon
   */
  canFitRoom( room ) {
    // Make sure the room fits inside the dungeon
    if ( room.x &lt; 0 || room.x + room.width &gt; this.width - 1 ) {
      return false;
    }
    if ( room.y &lt; 0 || room.y + room.height &gt; this.height - 1 ) {
      return false;
    }

    // Make sure this room doesn&apos;t intersect any existing rooms
    for ( let i = 0; i &lt; this.rooms.length; i++ ) {
      if ( room.overlaps( this.rooms[ i ] ) ) {
        return false;
      }
    }
    return true;
  }

  /**
   * Gets the full map of the dungeon
   * @return {Array.&lt;Array.&lt;Tiles&gt;&gt;} 2D map of the dungeon
   */
  getTiles() {
    const tiles = Array( this.height );
    for ( let r = 0; r &lt; this.height; r++ ) {
      tiles[ r ] = Array( this.width );
      for ( let c = 0; c &lt; this.width; c++ ) {
        tiles[ r ][ c ] = Tiles.EMPTY;
      }
    }

    // Fill in the map with details from each room
    for ( const room of this.rooms ) {
      for ( let r = 0; r &lt; room.height; r++ ) {
        for ( let c = 0; c &lt; room.width; c++ ) {
          tiles[ r + room.y ][ c + room.x ] = room.tiles[ r ][ c ];
        }
      }
    }

    return tiles;
  }

  /**
   * Gets the room at the specified location
   * @param {number} x The horizontal tile position
   * @param {number} y The vertical tile position
   * @return {Room|null} The room at the coordinate
   */
  getRoomAt( x, y ) {
    if ( x &lt; 0 || y &lt; 0 || x &gt;= this.width || y &gt;= this.height ) {
      return null;
    }
    return this.roomGrid[ y ][ x ][ 0 ]; // Assumes 1 room per tile
  }
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
